/* module to initialize and write PWM*/
/* code generated by chatGPT: (started with HAL then give further refinement)
write pwm driver code for nucleo-f446re for timer 1 channels 1-4 using low level library
* gave extra instruction to use #include <stm32f4xx_ll_tim.h>
* chat GPT code was missing master output enable
* TIM1: PWM1-4
* TIM4: PWM5-8
* TIM13 (PA6), TIM14 (PA7) pulse frequency output for stepper motor control
* note stepper motor drive needs 5V pullup resistor, so output mode shoudl be open drain
*/


#include <stm32f4xx_ll_tim.h>
#include "stm32f4xx_ll_bus.h"
#include "stm32f4xx_ll_gpio.h"
#include <zephyr.h>
#include <stdio.h>
#include "stm32_std.h"

/* PWM frequency and period */
#define PWM_FREQUENCY 2000  // 2kHz
#define PWM_PERIOD ((SystemCoreClock / PWM_FREQUENCY) - 1)

/* PWM duty cycle */
#define PWM_DUTY_CYCLE (PWM_PERIOD / 2)   // 50% duty cycle

#define MAXFREQ 3000 // maximum step motor pulse frequency (need to find value in Hz)

extern void printq_add(char *);
/****************************
 * Prototypes
******************************/

void set_pwm(int, uint32_t);
void generatePulses(int, int);
void stepOff(void);

// ------------ Local Variables ------------
static LL_TIM_OC_InitTypeDef tim_oc_init_struct;

void pwm_init(void)
{
    
    /* Enable GPIO clock */
    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOB);
    
    /* Enable TIM clock */
    LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_TIM1);
    LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM4);
    LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM13);
    LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM14);

   
// Configure GPIOB pins for TIM4 PWM output PB6-PB9, note AltFunc=2
  LL_GPIO_InitTypeDef GPIO_InitStruct;
  GPIO_InitStruct.Pin = LL_GPIO_PIN_6 | LL_GPIO_PIN_7 | LL_GPIO_PIN_8 | LL_GPIO_PIN_9;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  GPIO_InitStruct.Alternate = LL_GPIO_AF_2;
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);

// Configure GPIOA pins for TIM1 PWM output PA8-PA11, note AltFunc=1
    GPIO_InitStruct.Pin = LL_GPIO_PIN_8 | LL_GPIO_PIN_9 | LL_GPIO_PIN_10 | LL_GPIO_PIN_11;
    GPIO_InitStruct.Alternate = LL_GPIO_AF_1;
    LL_GPIO_Init(GPIOA, &GPIO_InitStruct);

// Configure GPIOA pins for TIM13 and TIM14 PWM output PA6-PA7, note AltFunc=9
// also use open drain with pull-up resistor
    GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_OPENDRAIN;
    GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE; 
    GPIO_InitStruct.Pin = LL_GPIO_PIN_6 | LL_GPIO_PIN_7;

    GPIO_InitStruct.Alternate = LL_GPIO_AF_9;
    LL_GPIO_Init(GPIOA, &GPIO_InitStruct);


// Configure GPIOC pins for StepMotor1 and 2 direction and enable
    GPIO_InitStruct.Pin = LL_GPIO_PIN_13 | LL_GPIO_PIN_14 | LL_GPIO_PIN_15;
    GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
    // StepMotor1DirPin LL_GPIO_PIN_13, StepMotor2DirPin LL_GPIO_PIN_14, StepMotorEnablePin LL_GPIO_PIN_15
    LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    LL_GPIO_ResetOutputPin(GPIOB, StepMotor1DirPin); // disable at initialize
    LL_GPIO_ResetOutputPin(GPIOB, StepMotor2DirPin);
    LL_GPIO_SetOutputPin(GPIOB, StepMotorFreePin); // disable at initialize (ENA=1 = free)

    /* Configure TIM peripheral */
    LL_TIM_InitTypeDef tim_init_struct;
    LL_TIM_StructInit(&tim_init_struct);
    tim_init_struct.Prescaler = 0;
    tim_init_struct.CounterMode = LL_TIM_COUNTERMODE_UP;
    tim_init_struct.Autoreload = PWM_PERIOD;
    tim_init_struct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
    LL_TIM_Init(TIM1, &tim_init_struct);
    LL_TIM_Init(TIM4, &tim_init_struct);
    LL_TIM_Init(TIM13, &tim_init_struct);
    LL_TIM_Init(TIM14, &tim_init_struct);


    /* Configure PWM channels */
    LL_TIM_OC_StructInit(&tim_oc_init_struct);
    tim_oc_init_struct.OCMode = LL_TIM_OCMODE_PWM1;
    tim_oc_init_struct.OCState = LL_TIM_OCSTATE_ENABLE;
    tim_oc_init_struct.CompareValue = PWM_DUTY_CYCLE;
    tim_oc_init_struct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;

    LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH1, &tim_oc_init_struct);
    LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH2, &tim_oc_init_struct);
    LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH3, &tim_oc_init_struct);
    LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH4, &tim_oc_init_struct);

    LL_TIM_OC_Init(TIM4, LL_TIM_CHANNEL_CH1, &tim_oc_init_struct);
    LL_TIM_OC_Init(TIM4, LL_TIM_CHANNEL_CH2, &tim_oc_init_struct);
    LL_TIM_OC_Init(TIM4, LL_TIM_CHANNEL_CH3, &tim_oc_init_struct);
    LL_TIM_OC_Init(TIM4, LL_TIM_CHANNEL_CH4, &tim_oc_init_struct);
    // start stepping motor frequency at 0
    tim_oc_init_struct.CompareValue = 0;
    LL_TIM_OC_Init(TIM13, LL_TIM_CHANNEL_CH1, &tim_oc_init_struct);
    LL_TIM_OC_Init(TIM14, LL_TIM_CHANNEL_CH1, &tim_oc_init_struct);

    /* Enable TIM counters */
    LL_TIM_EnableCounter(TIM1);
    LL_TIM_EnableCounter(TIM4);
    LL_TIM_EnableCounter(TIM13);
    LL_TIM_EnableCounter(TIM14);

     /* Master Output Enable MOE - this line was missing from ChatGPT example*/
    LL_TIM_EnableAllOutputs(TIM1);
    LL_TIM_EnableAllOutputs(TIM4);
    LL_TIM_EnableAllOutputs(TIM13);
    LL_TIM_EnableAllOutputs(TIM14);


    /* Enable PWM outputs */
    #ifdef DEBUG_PRINT
    printk("# End PWM init. TIM1 PA8 PA9 PA10 PA11, TIM4 PB6 PB7 PB8 PB9, PWM13 PA6, PWM14 PA7\n");
    #endif

}

void set_pwm(int chan, uint32_t value)
{   if (value < PWM_PERIOD)
    {    tim_oc_init_struct.CompareValue = value;   // set duty cycle to value 
    }
    else 
    {  tim_oc_init_struct.CompareValue = PWM_PERIOD-1; 
#ifdef DEBUG_PRINT
    printk("# set_pwm. value %d > PWM_PERIOD %d\n",
                value, PWM_PERIOD-1);
#endif
    }
    // need to make sure compare value is not greater than max count value
    switch(chan)
    {   case 1:
            LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH1, &tim_oc_init_struct);
            break;
        case 2:
            LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH2, &tim_oc_init_struct);
            break;
        case 3:
            LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH3, &tim_oc_init_struct);
            break;
        case 4:
            LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH4, &tim_oc_init_struct);
            break;
        case 5:
            LL_TIM_OC_Init(TIM4, LL_TIM_CHANNEL_CH1, &tim_oc_init_struct);
            break;
        case 6:
            LL_TIM_OC_Init(TIM4, LL_TIM_CHANNEL_CH2, &tim_oc_init_struct);
            break;
        case 7:
            LL_TIM_OC_Init(TIM4, LL_TIM_CHANNEL_CH3, &tim_oc_init_struct);
            break;
        case 8:
            LL_TIM_OC_Init(TIM4, LL_TIM_CHANNEL_CH4, &tim_oc_init_struct);
            break;
        default:
            printk("# pwm_set invalid channel %d\n",chan);
            break;
    }
}

void pwm_test(void)
{   uint16_t chan; 
    uint16_t value;
    uint32_t j =0;


    /* Initialize PWM */
   // pwm_init();

    while (1) 
    {   printk("# pwm test cycle %d\n", j);
        j++;
        for(chan = 1; chan <=8; chan++)
        {   printk("# Chan = %d ", chan); 
            // fflush(stdout);
            for(value = 0; value <= PWM_PERIOD; value=value+20)
            {  set_pwm(chan,value);
                k_msleep(1);
            }
        }    
    }
}




// pulse frequency in Hz
// SystemCoreClock is uint32_t
void generatePulses(int chan, int frequency) 
{
    uint16_t value; // limit to 16 bit register value
    uint16_t autoReload;
    char direction = 0;
    char log[TEXT_LINE_LENGTH];
    
    if ((frequency < -MAXFREQ) || (frequency > MAXFREQ))
    {   snprintf(log, sizeof(log),"# generatePulses freq %d exceeds MAXFREQ %d\n", frequency, MAXFREQ); 
        printq_add(log);
        return;
    }

     // Calculate the prescaler value
    uint16_t prescaleValue = (SystemCoreClock / 8000) - 1; // works for 96 MHz clock
    
    if (frequency == 0) // handle special case to avoid divide by zero for autoReload
    {   autoReload = 1;  // count to 1
        tim_oc_init_struct.CompareValue = 0;  // output set to 0, no pulses 
    }
    else
    {
        if(frequency < 0)
        {    direction = 1;
                value = (uint16_t)(-frequency);
        }
        else
        {   direction = 0; 
                value = (uint16_t) frequency;
        }
        // Calculate the auto-reload values based on the desired frequency
        autoReload = (prescaleValue / value) - 1;
        tim_oc_init_struct.CompareValue = autoReload/2;  // use 50% duty cycle 
    }   

  //  printk("# SystemCoreClock = %ld\n", SystemCoreClock);
    // Configure the timer with the calculated values

    switch(chan)
    {   case 1:     
            LL_TIM_SetPrescaler(TIM13, (uint32_t) prescaleValue);
            LL_TIM_SetAutoReload(TIM13, (uint32_t) autoReload);
            LL_TIM_OC_Init(TIM13, LL_TIM_CHANNEL_CH1, &tim_oc_init_struct);
            if (direction == 0)
                LL_GPIO_SetOutputPin(GPIOB, StepMotor1DirPin);
            else
                LL_GPIO_ResetOutputPin(GPIOB, StepMotor1DirPin);
           break;
        case 2:     
            LL_TIM_SetPrescaler(TIM14, (uint32_t) prescaleValue);
            LL_TIM_SetAutoReload(TIM14, (uint32_t) autoReload);
            LL_TIM_OC_Init(TIM14, LL_TIM_CHANNEL_CH1, &tim_oc_init_struct);
            if (direction == 0)
                LL_GPIO_SetOutputPin(GPIOB, StepMotor2DirPin);
            else
                LL_GPIO_ResetOutputPin(GPIOB, StepMotor2DirPin);
            break;
        default:
            printk("# generatePulses invalid channel %d\n",chan);
            break;
    }       
    LL_GPIO_ResetOutputPin(GPIOB, StepMotorFreePin); // enable only after frequency is set
}

// set stepping motors to free (not energized)
void stepOff(void)
{
     LL_GPIO_SetOutputPin(GPIOB, StepMotorFreePin); // de-energize motore
}

