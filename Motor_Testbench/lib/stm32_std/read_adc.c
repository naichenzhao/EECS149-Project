/* Interface to read individual A/D channels using low level library
* code mostly generated by ChatGPT:
* > write code to read ADC123_IN10 to ADC123_IN15 on nucleo-f446re using low level library
* > Use LL instead of HAL
* > add initialization code for ADC input on PB0, PB1, PC0 to PC5
==> note chatGPT inserted non-existent LL commands, single ended nonsense

PB0		ADC12_IN8		CN7-34
PB1		ADC12_IN9		CN10-24
PC0		ADC123_IN10		CN7-38
PC1		ADC123_IN11		CN7-36
PC2		ADC123_IN12		CN7-35
PC3		ADC123_IN13		CN7-37
PC4		ADC123_IN14		CN10-34
PC5		ADC123_IN15		CN10-6
 */

#include "stm32f4xx.h"
#include <sys/printk.h>
#include <soc.h> 
#include "stm32f4xx_ll_adc.h"
#include "stm32f4xx_ll_bus.h"
#include "stm32f4xx_ll_gpio.h"
#include "stm32f4xx_ll_rcc.h"
#include <zephyr.h>
#include "stm32_std.h"

/****************************
 * Prototypes
******************************/

void adc_init(void);
void adc_test();
uint16_t read_adc(int);

void adc_init(void)
{    // Enable ADC clock
    LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_ADC1);
    // Enable GPIOB and GPIOC clock
    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOB);
    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);
    
    // Initialize GPIO pins
    // Configure PB0 and PB1 as analog inputs
    LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_0, LL_GPIO_MODE_ANALOG);
    LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_1, LL_GPIO_MODE_ANALOG);

    // Configure PC0 to PC5 as analog inputs
    LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_0, LL_GPIO_MODE_ANALOG);
    LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_1, LL_GPIO_MODE_ANALOG);
    LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_2, LL_GPIO_MODE_ANALOG);
    LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_3, LL_GPIO_MODE_ANALOG);
    LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_4, LL_GPIO_MODE_ANALOG);
    LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_5, LL_GPIO_MODE_ANALOG);

    // Initialize ADC
    LL_ADC_InitTypeDef adcInitStruct;
    LL_ADC_StructInit(&adcInitStruct);
    adcInitStruct.Resolution = LL_ADC_RESOLUTION_12B;
    adcInitStruct.DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;
    adcInitStruct.SequencersScanMode = LL_ADC_SEQ_SCAN_ENABLE;
    LL_ADC_Init(ADC1, &adcInitStruct);

    // Configure ADC channels
    LL_ADC_REG_InitTypeDef adcRegInitStruct;
    LL_ADC_REG_StructInit(&adcRegInitStruct);
    adcRegInitStruct.TriggerSource = LL_ADC_REG_TRIG_SOFTWARE;
    adcRegInitStruct.SequencerLength = LL_ADC_REG_SEQ_SCAN_DISABLE;
    LL_ADC_REG_Init(ADC1, &adcRegInitStruct);

 // Configure ADC clock
    LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(ADC1), LL_ADC_CLOCK_SYNC_PCLK_DIV2);
    LL_ADC_Enable (ADC1); // power on ADC1
    LL_ADC_REG_SetTriggerSource (ADC1, LL_ADC_REG_TRIG_SOFTWARE);
    
    // Configure individual channels
    LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_8, LL_ADC_SAMPLINGTIME_3CYCLES);  
    LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_9, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_10, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_11, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_12, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_13, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_14, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_15, LL_ADC_SAMPLINGTIME_3CYCLES);
    #ifdef DEBUG_PRINT
    printk("# End ADC init PB0 PB1 PC0 PC1 PC2 PC3 PC4 PC5\n");
    #endif
}

uint16_t read_adc(int channel)
{   uint16_t adc_value;
    int timeout = 0;   // for safety, otherwise will busy wait forever
    // start conversion with software trigger
    LL_ADC_REG_SetSequencerRanks(ADC1, LL_ADC_REG_RANK_1, channel);
    LL_ADC_REG_StartConversionSWStart(ADC1);  // software start for conversion

    while ((!LL_ADC_IsActiveFlag_EOCS(ADC1)) && (timeout < 1000)) // end of conversion sequence 
    {   timeout++; // Wait for end of conversion
    }
    if(timeout < 1000)
    { adc_value = LL_ADC_REG_ReadConversionData12(ADC1);
      return(adc_value);
    }  
    else
    { printk("# ADC_ReadValue timeout\n");    
        return(0xffff);
    }
}

void adc_test(void)
{   uint32_t channel;
    uint16_t adcValue;
    
    adc_init(); // Initialize ADC

    while (1)
    {  
        for (channel = 8; channel <= 15; channel++)
        {   adcValue = read_adc(channel);
            printk("# chan %d = %d\t", channel, adcValue);
        }
        printk("\n");
        k_msleep(1000);
    }
}

